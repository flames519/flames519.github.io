{"./":{"url":"./","title":"自述","keywords":"","body":"自述 你好，我很好 长大的过程 就是舍得的过程 最难的过程不是取舍不定 是计较已得与已失 你可以在vccode 快捷方式里加上这样一句 来改变插件安转位置 如果你不想放在C盘的话 不过后来我发现 也许根本用不到这么多插件 --extensions-dir D:\\Data\\VScode\\extensions 同理 你可以改一下 npm 全局仓库的安装目录 其实也不需要很多 npm config set prefix=\"D:\\Data\\nodejs\\npm_global\" npm config set cache=\"D:\\Data\\nodejs\\npm_cache\" 这曾经是很头疼的问题 node-sass 的安转问题 不过现在好像也不是什么问题了 可以统一在.npmrc 文件配置 npm config set sass_binary_site=https://npm.taobao.org/mirrors/node-sass gitbook markdown "},"VUE/vue.html":{"url":"VUE/vue.html","title":"vue","keywords":"","body":"vue可以不会，代码一定要骚 vue 你想要的这里都有vue2官方文档 如果没有，当我没说 # 使用vueCli 创建一个demo npx vue create [project name] cd [project name] npm run start 使用命令创建vue项目 小计 linux node10版本以上打包vuecli 会出错 serve 快速创建一个本地webf服务 默认端口 5000 nodemon 持续监听执行文件 nrm 快速更改npm的镜像 npx nrm ls npx nrm use taobao nrm常用命令 nvm 管理node版本 一般10最稳定 nvm-git nvm常用命令 "},"VUE--Cart/01.html":{"url":"VUE--Cart/01.html","title":"01","keywords":"","body":"01.Cart-header 一只想用ts构建一个项目 使用了ant组件为了更(bu)好(xiang)的(zi)看(ji)的(xie)样式 按钮 --> null\"> {{headleBtn}} {{isEdit ? \"编辑\" : \"完成\"}} --> 编辑 --> 完成 --> 编辑 --> 完成 --> oh~~~~ 别的不说，一个vue 文件里data 和 methods 隔着十万八千里，上下翻动太累了 // lang = \"ts\" import { Component, Prop, Vue } from \"vue-property-decorator\"; // ts 装饰器 @Component({ name: \"Cart\", }) export default class Cart extends Vue { // data private isEdit: boolean = true; // computer private get headleBtn() { return this.isEdit ? \"编辑\" : \"完成\"; } } "},"VUE--Cart/02.html":{"url":"VUE--Cart/02.html","title":"02","keywords":"","body":"02.组件化 简简单单的一个头部组件，占了很多行数 看着相当不痛快 但凡是看着不爽的，那就提组件吧 就是这么舒服 子组件 :propName=\"\" @方法=\"\" 子组件使用 prop 接收 父组件传递的变量 使用$emit 触发父组件监听的事件 :usEdit.sync --- > 语法糖 === :isEdit=\"isEdit\" @update:isEdit=\"val=>isEdit=val\" --> //cart.vue import { Component, Prop, Vue } from \"vue-property-decorator\"; import CartHeader from \"../../components/cart/CartHeader\" // ts 装饰器 @Component({ name: \"Cart\", components:{CartHeader} }) export default class Cart extends Vue { // data private isEdit: boolean = true; } // CartHeader.tsx import { Component, Prop, Vue, Emit } from \"vue-property-decorator\"; @Component({ name: \"CartHeader\", }) export default class CartHeader extends Vue { // props @Prop({ default: true }) isEdit!: boolean; // computer private get headleBtn() { return this.isEdit ? \"编辑\" : \"完成\"; } // $emit @Emit(\"update:isEdit\") updateIsEdit() { return !this.isEdit; } protected render() { return ( null}> this.updateIsEdit()}> {this.headleBtn} ); } } "},"VUE--Cart/03-1.html":{"url":"VUE--Cart/03-1.html","title":"03-1","keywords":"","body":"03.cart-content 03.1 一不小心就写完了，样式凑合凑合吧，主要实现功能是吧 选择和全选 店铺和商品双向关联 删除 删除使用isDel 控制 不对原数据进行增减 计算总价 计算属性 + render 深层组件间传值 v-bind=\"$attrs\" v-on=\"$listeners 就是爷爷给后代的属性和事件全部给爸爸，然后爸爸挑出自己用的，然后把用不到的通过$attrs,$listener传给下一代，优秀了 还有一种方法 provide / inject 这就厉害了，不需要一层一层的传了，直接爷爷 ==> provide 后代谁需要 ==> inject provide 运行在 生命周期 created 之前 细节：=====> v-if && v-for v-if 和 v-for 不能再同一行使用，谁都知道 why? v-for 的优先级比 v-if 高 ===> 源码就是这摸写的 我还能怎么看 以后再说，先看看怎么用 如果是判断要不要渲染这次循环 那超级简单了 提一层 if > for 解决问题 那如果是循环内部呢，这里我控制商品删除使用的 isDel 的字段 这就意味着我是否渲染商品 不是外部控制 而是内部控制 好的吧 if - for 不能放同一层 分开不就好了嘛 for - if WFT !!!! 这和放一起有区别嘛 ...... 那怎么办 ！！ computer 还记得这货嘛 有啥用？ 再加上 Array.fifter() 呢 优秀了 可以使用计算属性获取没有被删除的商品 for ==> 只循环需要没有被删除的商品 ojbk 改造一下 {{isAll ? \"取消全选\":\"全选\"}} 总计：{{totalPrice | priceF}} {{isEdit?\"提交订单\":\"删除\"}} --> --> {{shop.name}} --> 商品: {{ goods.title}} 价格：{{goods.price | priceF}} 数量： goods.num>1&&goods.num--\">－ {{goods.num}} goods.num＋ "},"VUE--Cart/03-2.html":{"url":"VUE--Cart/03-2.html","title":"03-2","keywords":"","body":"03.cart-content 03.2 太长 分一下 script 部分 难受 逻辑居然没分出去 // cart.vue import { Component, Prop, Vue } from \"vue-property-decorator\"; import { filter } from \"vue/types/umd\"; import CartHeader from \"../../components/cart/CartHeader\"; import CartContent from \"../../components/cart/CartContent.vue\"; import \"../../components/cart/CartTypes\"; // ts 装饰器 @Component({ name: \"Cart\", components: { CartHeader, CartContent }, }) export default class Cart extends Vue { // data private isEdit: boolean = true; private dataList: Shop[] = []; private goodsLoading: boolean = true; // choose sTop(shop: Shop) { let bol: boolean = shop.isChecked; shop.goods.forEach((p) => (p.isChecked = bol)); } pTos(shop: Shop) { shop.isChecked = shop.goods.every((g) => g.isChecked); } chooseGoods(goods: Goods, shop: Shop) { let bol = goods.isChecked; goods.isChecked = !bol; this.pTos(shop); } chooseShop(shop: Shop, bol: boolean) { shop.isChecked = !bol; this.sTop(shop); } chooseAll() { let bol = this.isAll; this.dataList.forEach((s) => { this.chooseShop(s, bol); }); } // headle headle() { if (!this.isEdit) { // del this.dataList.forEach((s) => { if (s.isChecked) { s.isDel = true; s.goods.forEach((g) => (g.isDel = true)); } else { s.goods.forEach((g) => (g.isDel = g.isChecked)); } }); } else { // submit } } // computer get isAll() { return this.dataList.every((s) => s.isChecked); } get totalPrice() { return this.dataList.reduce( (pre, p) => pre + p.goods.reduce( (s, i) => !i.isDel && i.isChecked ? s + parseFloat(i.price + \"\") * i.num : s, 0 ), 0 ); } // mounted public mounted() { setTimeout(() => { console.log(\"welcome Cart\"); this.dataList = [ { name: \"商店a\", goods: [ { title: \"a1\", price: 30, num: 1, isChecked: false, isDel: false }, { title: \"a2\", price: 10, num: 3, isChecked: true, isDel: false }, ], isChecked: false, isDel: false, }, { name: \"商店b\", goods: [ { title: \"b1\", price: 30, num: 1, isChecked: true, isDel: false }, { title: \"b2\", price: 10, num: 3, isChecked: true, isDel: false }, ], isChecked: true, isDel: false, }, ]; this.goodsLoading = false; }, 3000); } } // CartContent.vue import { Component, Prop, Vue } from \"vue-property-decorator\"; import ShopItem from \"./ShopItem.vue\"; @Component({ name: \"CartContent\", components: { ShopItem }, }) export default class CartContent extends Vue { @Prop({ default: true }) goodsLoading!: boolean; @Prop({ default: () => [] }) dataList!: Shop[]; // computer private get noDelDataList() { return this.dataList.filter((shop) => !shop.isDel); } } // ShopItem.vue import { Component, Emit, Prop, Vue } from \"vue-property-decorator\"; @Component({ name: \"ShopItem\", }) export default class ShopItem extends Vue { // props @Prop({default:()=>{}}) shop!:Shop // computer private get noDelGoods() { return this.shop.goods.filter((goods) => !goods.isDel); } // $emit @Emit(\"chooseGoods\") chooseGoods(goods:Goods,shop:Shop){} // $emite ===> this.$emist(\"choseShop\") @Emit(\"chooseShop\") chooseShop(shop:Shop,bol:boolean){} mounted() { console.log(this.$attrs); console.log(this.$listeners); } } "},"Webpack/simple-webpack.html":{"url":"Webpack/simple-webpack.html","title":"simple-webpack","keywords":"","body":"webpack webpack 目前主流的打包工具，用的懵懵懂懂，翻翻文档，使用是没什么问题 至于内部到底如何运行，如何组合，还是要看源码 这里简单实现了 js 代码的组合 目录结构 | simple-webpack |--config 配置文件夹 -- webpack.config.js 配置项目的入口文件和出口目录和文件名 |--src 项目文件夹 --index.js 入口文件 |-- js 模块文件夹 |--dist 出口文件夹 |--lib webpack 实现目录 --app.js 运行webpack --webpack.js // config/webpack.confing.js // 只实现了js相关文件 const path = require(\"path\"); module.exports = { entry: \"./src/index.js\", output: { filename: \"bundle.js\", path: path.resolve(__dirname, \"../dist\"), }, // mode: \"development\", }; // src/index.js import { a } from \"./js/a.js\"; import { b } from \"./js/b.js\"; console.log(`info: ${a},${b}`); // src/js/a.js export const a = \"my name is xxx\" // src/js/b.js import { c } from \"./c.js\"; console.log(c); export const b = \"my code is good\"; // src/js/c.js export const c = \"c\" // 目标 生产可运行的bundle.js文件 开始实现代码 依赖： 使用babel相关工具解析js代码 // 读取文件内容生产ast @babel/parser // 过滤ast @babel/traverse // 解析转化代码 @babel/core @babel/preset-env // lib/webpack const fs = require(\"fs\"); const path = require(\"path\"); // 获取项目路径 const dirPath = path.dirname(__dirname); // 解析文件内容 const parser = require(\"@babel/parser\"); // 过滤ast const traverse = require(\"@babel/traverse\").default; // 解析 const babel = require(\"@babel/core\"); module.exports = class Webpack { constructor(option) { this.entry = option.entry; this.output = option.output; } run() { // console.log(this.code()); const code = this.code(this.entry) const { path: filepath, filename } = this.output; fs.writeFileSync(path.join(filepath, filename), code, \"utf-8\"); } code(entry) { const graph = JSON.stringify(this.parse(entry)); // console.log(this.parse(entry)); // console.log(); return `(function (graph) { function require(module) { eval(\"console.log(module)\") function localRequire(relativePath) { return require(graph[module].dependencies[relativePath]); } var exports = {}; // eval(graph[module][\"code\"]) function fn(require, exports, code) { eval(code); } fn(localRequire, exports, graph[module][\"code\"]); return exports; } require(\"${entry}\") })(${graph});`; } parse(filename) { const graph = {}; const content = fs.readFileSync(path.resolve(dirPath, filename), \"utf-8\"); // console.log(content); // sourceType: \"module\" // 获取ast const ast = parser.parse(content, { sourceType: \"module\" }); // console.log(ast.program.body[0].source); // 筛选ast，获取文件内容中的模块相关内容 const dependencies = {}; traverse(ast, { ImportDeclaration: ({ node }) => { // console.log(node); // path.relative(from, to) // 求出相对根目录的路径 const filePath = path.relative( dirPath, path.join( path.resolve(dirPath, path.dirname(filename)), node.source.value ) ); dependencies[node.source.value] = filePath; }, }); // 将源代码解析 const { code } = babel.transformFromAst(ast, null, { presets: [\"@babel/preset-env\"], }); // 保存文件依赖和内容 graph[filename] = { dependencies, code, }; // 递归 Object.keys(dependencies) .map((f) => this.parse(dependencies[f])) .forEach((m) => Object.assign(graph, m)); // 返回 return graph; } }; // lib/app.js const Webpack = require(\"./webpack\"); const config = require(\"../config/webpack.config\"); const webpack = new Webpack(config); webpack.run(); // 结果 (function (graph) { function require(module) { eval(\"console.log(module)\") function localRequire(relativePath) { return require(graph[module].dependencies[relativePath]); } var exports = {}; // eval(graph[module][\"code\"]) function fn(require, exports, code) { eval(code); } fn(localRequire, exports, graph[module][\"code\"]); return exports; } require(\"./src/index.js\") })({\"./src/index.js\":{\"dependencies\":{\"./js/a.js\":\"src/js/a.js\",\"./js/b.js\":\"src/js/b.js\"},\"code\":\"\\\"use strict\\\";\\n\\nvar _a = require(\\\"./js/a.js\\\");\\n\\nvar _b = require(\\\"./js/b.js\\\");\\n\\nconsole.log(\\\"info: \\\".concat(_a.a, \\\",\\\").concat(_b.b));\"},\"src/js/a.js\":{\"dependencies\":{},\"code\":\"\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n value: true\\n});\\nexports.a = void 0;\\nvar a = \\\"my name is xxx\\\";\\nexports.a = a;\"},\"src/js/b.js\":{\"dependencies\":{\"./c.js\":\"src/js/c.js\"},\"code\":\"\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n value: true\\n});\\nexports.b = void 0;\\n\\nvar _c = require(\\\"./c.js\\\");\\n\\nconsole.log(_c.c);\\nvar b = \\\"my code is good\\\";\\nexports.b = b;\"},\"src/js/c.js\":{\"dependencies\":{},\"code\":\"\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n value: true\\n});\\nexports.c = void 0;\\nvar c = \\\"c\\\";\\nexports.c = c;\"}}); "}}